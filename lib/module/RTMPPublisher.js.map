{"version":3,"sources":["RTMPPublisher.tsx"],"names":["React","forwardRef","useImperativeHandle","Animated","NativeModules","StyleSheet","View","GestureHandlerRootView","PinchGestureHandler","State","RTMPView","RTMPModule","RTMPPublisher","ref","onConnectionFailed","onConnectionStarted","onConnectionSuccess","onDisconnect","onNewBitrateReceived","onStreamStateChanged","props","_root","useRef","startStream","stopStream","isStreaming","isCameraOnPreview","getPublishURL","hasCongestion","isAudioPrepared","isVideoPrepared","isMuted","mute","unmute","switchCamera","toggleFlash","handleOnConnectionFailed","e","nativeEvent","data","handleOnConnectionStarted","handleOnConnectionSuccess","handleOnDisconnect","handleOnNewBitrateReceived","handleOnStreamStateChanged","_baseScale","Value","_pinchScale","_lastScale","_onPinchHandlerStateChange","event","oldState","ACTIVE","numberOfPointers","scale","setValue","flex","styles","style","current","setNativeProps","zoom","backgroundColor","create","absolute","position"],"mappings":"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","sourcesContent":["import React, { forwardRef, useImperativeHandle } from 'react';\nimport {\n  Animated,\n  NativeModules,\n  StyleSheet,\n  View,\n  ViewStyle,\n} from 'react-native';\nimport {\n  GestureHandlerRootView,\n  HandlerStateChangeEvent,\n  PinchGestureHandler,\n  PinchGestureHandlerEventPayload,\n  State,\n} from 'react-native-gesture-handler';\nimport RTMPView, {\n  ConnectionFailedType,\n  ConnectionStartedType,\n  ConnectionSuccessType,\n  DisconnectType,\n  NewBitrateReceivedType,\n  RefNativeRTMPPublisherProps,\n  StreamStateChangedType,\n} from './Component';\nimport type { RTMPPublisherRefProps, StreamState } from './types';\n\nconst RTMPModule = NativeModules.RTMPPublisher;\nexport interface RTMPPublisherProps {\n  style?: ViewStyle;\n  streamURL: string;\n  streamName: string;\n  /**\n   * Determines if preview is displayed as landscape\n   */\n  IsLandscape: boolean;\n  /**\n   * Callback for connection fails on RTMP server\n   */\n  onConnectionFailed?: (data: string) => void;\n  /**\n   * Callback for starting connection to RTMP server\n   */\n  onConnectionStarted?: (data: string) => void;\n  /**\n   * Callback for connection successfully to RTMP server\n   */\n  onConnectionSuccess?: (data: null) => void;\n  /**\n   * Callback for disconnect successfully to RTMP server\n   */\n  onDisconnect?: (data: null) => void;\n  /**\n   * Callback for receiving new bitrate value about stream\n   */\n  onNewBitrateReceived?: (data: number) => void;\n  /**\n   * Alternatively callback for changing stream state\n   * Returns parameter StreamState type\n   */\n  onStreamStateChanged?: (data: StreamState) => void;\n}\n\nconst RTMPPublisher = forwardRef<RTMPPublisherRefProps, RTMPPublisherProps>(\n  (\n    {\n      onConnectionFailed,\n      onConnectionStarted,\n      onConnectionSuccess,\n      onDisconnect,\n      onNewBitrateReceived,\n      onStreamStateChanged,\n      ...props\n    },\n    ref\n  ) => {\n    const _root = React.useRef<RefNativeRTMPPublisherProps>(null);\n\n    const startStream = async () => await RTMPModule.startStream();\n\n    const stopStream = async () => await RTMPModule.stopStream();\n\n    const isStreaming = async () => RTMPModule.isStreaming();\n\n    const isCameraOnPreview = async () => RTMPModule.isCameraOnPreview();\n\n    const getPublishURL = async () => RTMPModule.getPublishURL();\n\n    const hasCongestion = async () => RTMPModule.hasCongestion();\n\n    const isAudioPrepared = async () => RTMPModule.isAudioPrepared();\n\n    const isVideoPrepared = async () => RTMPModule.isVideoPrepared();\n\n    const isMuted = async () => RTMPModule.isMuted();\n\n    const mute = () => RTMPModule.mute();\n\n    const unmute = () => RTMPModule.unmute();\n\n    const switchCamera = () => RTMPModule.switchCamera();\n\n    const toggleFlash = () => RTMPModule.toggleFlash();\n\n    const handleOnConnectionFailed = (e: ConnectionFailedType) => {\n      onConnectionFailed && onConnectionFailed(e.nativeEvent.data);\n    };\n\n    const handleOnConnectionStarted = (e: ConnectionStartedType) => {\n      onConnectionStarted && onConnectionStarted(e.nativeEvent.data);\n    };\n\n    const handleOnConnectionSuccess = (e: ConnectionSuccessType) => {\n      onConnectionSuccess && onConnectionSuccess(e.nativeEvent.data);\n    };\n\n    const handleOnDisconnect = (e: DisconnectType) => {\n      onDisconnect && onDisconnect(e.nativeEvent.data);\n    };\n\n    const handleOnNewBitrateReceived = (e: NewBitrateReceivedType) => {\n      onNewBitrateReceived && onNewBitrateReceived(e.nativeEvent.data);\n    };\n\n    const handleOnStreamStateChanged = (e: StreamStateChangedType) => {\n      onStreamStateChanged && onStreamStateChanged(e.nativeEvent.data);\n    };\n\n    useImperativeHandle(ref, () => ({\n      startStream,\n      stopStream,\n      isStreaming,\n      isCameraOnPreview,\n      getPublishURL,\n      hasCongestion,\n      isAudioPrepared,\n      isVideoPrepared,\n      isMuted,\n      mute,\n      unmute,\n      switchCamera,\n      toggleFlash,\n    }));\n\n    const _baseScale = new Animated.Value(1);\n    const _pinchScale = new Animated.Value(1);\n    var _lastScale = 1;\n\n    const _onPinchHandlerStateChange = (\n      event: HandlerStateChangeEvent<PinchGestureHandlerEventPayload>\n    ) => {\n      // console.log('RE');\n      // console.log({ _lastScale });\n      if (\n        event.nativeEvent.oldState === State.ACTIVE &&\n        event.nativeEvent.numberOfPointers === 2\n      ) {\n        _lastScale *= event.nativeEvent.scale;\n        _lastScale < 1 && (_lastScale = 1);\n        _lastScale > 3 && (_lastScale = 3);\n        _baseScale.setValue(_lastScale);\n        _pinchScale.setValue(1);\n      }\n    };\n\n    // const [viewDimension, setViewDimension] = React.useState<LayoutRectangle>({\n    //   width: 0,\n    //   height: 0,\n    //   x: 0,\n    //   y: 0,\n    // });\n\n    // const scale = useSharedValue(1);\n    // const savedScale = useSharedValue(1);\n\n    // function setZoom(_scale: number) {\n    //   _root.current?.setNativeProps({\n    //     zoom: `${_scale}`,\n    //   });\n    // }\n\n    // const pinchGesture = Gesture.Pinch()\n    //   .onUpdate((e) => {\n    //     scale.value = savedScale.value * e.scale;\n    //     console.log({\n    //       scale: scale.value,\n    //       savedScale: savedScale.value,\n    //       root: _root?.current,\n    //     });\n\n    //     runOnJS(setZoom)(scale.value)\n    //     // _root.current?.setNativeProps({\n    //     //   zoom: `${scale.value}`,\n    //     // });\n    //   })\n    //   .onEnd(() => {\n    //     console.log('pinched', scale.value, savedScale.value);\n    //     savedScale.value = scale.value;\n    //   });\n\n    // pinchGesture.config = { runOnJS: true };\n    // const tap = Gesture.Tap()\n    //   .numberOfTaps(2)\n    //   .onEnd(() => {\n    //     switchCamera();\n    //   });\n\n    // const gestures = Gesture.Exclusive(tap, pinchGesture);\n\n    // const animatedStyle = useAnimatedStyle(() => ({\n    //   transform: [{ scale: scale.value }],\n    // }));\n\n    return (\n      <GestureHandlerRootView style={{ flex: 1 }}>\n        <View style={[styles.flex, props.style]}>\n          {/* <GestureDetector gesture={gestures}> */}\n\n          <PinchGestureHandler\n            onGestureEvent={(event) => {\n              _root.current?.setNativeProps({\n                zoom: `${_lastScale * event.nativeEvent.scale}`,\n              });\n            }}\n            onHandlerStateChange={_onPinchHandlerStateChange}\n          >\n            <Animated.View\n              style={[styles.flex, { backgroundColor: 'red' }]}\n              collapsable={false}\n            >\n              <RTMPView\n                ref={_root as any}\n                {...props}\n                onDisconnect={handleOnDisconnect}\n                onConnectionFailed={handleOnConnectionFailed}\n                onConnectionStarted={handleOnConnectionStarted}\n                onConnectionSuccess={handleOnConnectionSuccess}\n                onNewBitrateReceived={handleOnNewBitrateReceived}\n                onStreamStateChanged={handleOnStreamStateChanged}\n              />\n            </Animated.View>\n          </PinchGestureHandler>\n\n          {/* </GestureDetector> */}\n          {/* <Button\n            title=\"ss\"\n            onPress={() => {\n              _root.current?.setNativeProps({\n                zoom: `${scale.value}`,\n              });\n            }}\n          >\n            s\n          </Button> */}\n        </View>\n      </GestureHandlerRootView>\n    );\n  }\n);\n\n{\n  /* <GestureHandlerRootView\n        style={[styles.flex, props.style]}\n        onLayout={(event) => {\n          setViewDimension(event.nativeEvent.layout);\n        }}\n      ></GestureHandlerRootView> */\n}\n\nconst styles = StyleSheet.create({\n  absolute: { position: 'absolute' },\n  flex: { flex: 1 },\n});\n\nexport default RTMPPublisher;\n"]}